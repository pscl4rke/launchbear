#!/usr/bin/env python

"""
//  LAUNCHBEAR

Launchbear is a piece of middleware designed to launch applications
in a GUI environment.  It takes selectable items from plugins, and
allows them to be picked using a front-end.
"""


import os
import shlex
import subprocess
try:
    import cPickle as pickle
except ImportError as e:
    import pickle


class HistoryFile:
    """Tracks what has been launched to order by popularity."""

    max_history = 500

    def __init__(self):
        self.location = os.path.join(os.environ['HOME'], ".launchbear", "history")
        self.history = []
        try:
            with open(self.location) as infile:
                for line in infile:
                    self.history.append(line.strip())
        except IOError:
            pass # presumably doesn't exist yet

    def update(self, choice_id):
        self.history.append(choice_id)
        if len(self.history) > self.max_history:
            self.history.pop(0)
        with open(self.location, 'w') as outfile:
            for choice_id in self.history:
                outfile.write("%s\n" % choice_id)

    def score(self, choice_id):
        score = 0
        for previous in self.history:
            if previous == choice_id:
                score += 1
        return score


class ChoiceGenerator:
    """A backend that provides a number of choices."""

    def __init__(self):
        """Create a new ChoiceGenerator."""
        self._choices = []

    def choices(self):
        """Returns a set of choices."""
        choices_available = {}
        for choice in self._choices:
            if "id" not in choice:
                continue
            choices_available[choice["id"]] = choice
        return choices_available

    def parse(self, stream):
        """Build a set of choices from a file stream."""
        for line in stream.readlines():
            arguments = shlex.split(line, comments=True)
            if len(arguments) == 0:
                continue
            handler_name = "handle_%s" % arguments[0]
            if not hasattr(self, handler_name):
                print "Unknown directive '%s'" % arguments[0]
            else:
                getattr(self, handler_name)(arguments[1:])

    def load(self, cached_data):
        """Build a set of choices from previously cached data."""
        if 'choices' in cached_data:
            self._choices = cached_data['choices']
        else:
            self._choices = {}

    def save(self):
        """Returns the cache form that can be loaded."""
        return {
            'choices': self._choices,
        }

    def handle_addchoice(self, arguments):
        choice_properties = {}
        for argument in arguments:
            if not argument.startswith("--"):
                continue
            dashed_key, equals, value = argument.partition("=")
            if equals != "=":
                continue
            choice_properties[dashed_key[2:]] = value
        self._choices.append(choice_properties)


class DmenuFrontend:
    """A picker based around dmenu."""

    def pick(self, choices):
        """Presents the choices and returns the id chosen or None."""
        lines = []
        for choice in choices:
            parts = []
            if 'title' in choice:
                parts.append(choice['title'])
            if 'cmd' not in choice:
                continue
            parts.append("(%s)" % choice['cmd'])
            if 'id' not in choice:
                continue
            parts.append("||| %s" % choice['id'])
            lines.append(" ".join(parts))
        command = [
            "dmenu", "-i", "-l", "6",
            "-fn", "-*-arial-*-r-*-*-*-*-*-*-*-*-*",
            "-nb", "#444", "-nf", "#DDD", "-sb", "#757",
            "-p", "Run:",
        ]
        process = subprocess.Popen(command,
                    stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        stdout, stderr = process.communicate("\n".join(lines))
        if len(stdout) == 0:
            return None
        rest, bars, choice_id = stdout.strip().partition("||| ")
        return choice_id


def load_cachefile():
    """Return the cached data, or blank data."""
    homedir = os.environ['HOME']
    cache_path = os.path.join(homedir, ".launchbear/cache.pkl")
    if os.path.exists(cache_path):
        cache_file = open(cache_path)
        return pickle.load(cache_file)
    return {
        'generators': {},
    }


def save_cachefile(cache):
    """Saves the given cache to disk."""
    homedir = os.environ['HOME']
    cache_path = os.path.join(homedir, ".launchbear/cache.pkl")
    cache_file = open(cache_path, "w")
    pickle.dump(cache, cache_file)
    cache_file.close()


def main():
    homedir = os.environ['HOME']
    backend_home = os.path.join(homedir, ".launchbear/backends")
    backend_names = os.listdir(backend_home)
    cache = load_cachefile()
    history = HistoryFile()
    all_choices = {}
    for backend_name in backend_names:
        generator = ChoiceGenerator()
        if backend_name in cache['generators']:
            generator.load(cache['generators'][backend_name])
        else:
            backend_location = os.path.join(backend_home, backend_name)
            process = subprocess.Popen(backend_location,
                        stdout=subprocess.PIPE, shell=True)
            infile = process.stdout
            generator.parse(infile)
            cache['generators'][backend_name] = generator.save()
        choices_available = generator.choices()
        all_choices.update(choices_available)
    save_cachefile(cache)
    frontend = DmenuFrontend()
    sortable_choices = [(history.score(x['id']), x) for x in all_choices.values()]
    sortable_choices.sort(reverse=True)
    choice_id = frontend.pick(y for (i, y) in sortable_choices)
    if choice_id is not None:
        history.update(choice_id)
        command = "%s &" % all_choices[choice_id]['cmd']
        subprocess.call(command, shell=True)


if __name__ == '__main__':
    main()


